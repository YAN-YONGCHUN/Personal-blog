<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>算法分享</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Lato:wght@400;700&family=Montserrat:wght@600;700&family=Fira+Code:wght@400;600&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="./assets/styles.css">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/themes/prism-okaidia.min.css">
  <link rel="stylesheet" href="./assets/cyber.css">
</head>
<body>
  <nav class="nav">
    <div class="container wrap">
      <a class="brand" href="index.html"><div class="logo">IT</div><strong>技术博客</strong></a>
      <button id="hamburger" class="hamburger">☰</button>
      <div id="menu" class="menu">
        <a href="index.html">主页</a>
        <a class="active" href="algorithms.html">算法分享</a>
        <div class="dropdown">
          <a href="modeling.html">建模分享 ▾</a>
          <div class="dropdown-menu">
            <a href="modeling.html?category=算法模型">算法模型</a>
            <a href="modeling.html?category=应用案例">应用案例</a>
            <a href="modeling.html?category=理论研究">理论研究</a>
          </div>
        </div>
        <a href="projects.html">项目展示</a>
        <a href="about.html">关于我</a>
        <a href="blog.html">博客</a>
        <a href="contact.html">联系方式</a>
      </div>
    </div>
  </nav>

  <header class="hero"><div class="container"><h1>如果热爱就放手一博吧</h1><p>图论，搜索，贪心相关分享</p><img src="./assets/2.jpg" alt="算法页头图" class="header-image"></div></header>

  <main>
    <section class="section"><div class="container">
      <div id="algoTabs" class="tabs-container">
        <button class="btn btn-primary algo-tab" data-target="problems">算法题解</button>
        <button class="btn btn-outline algo-tab" data-target="algorithms">算法展示</button>
      </div>

      <div id="problems">
        <div class="grid posts">
          <article class="card">
            <h3>两数之和</h3>
            <p>给定数组与目标值，返回两数下标。哈希表一次遍历。</p>
            <button class="btn btn-outline btn-sm toggle-code" style="margin-top:16px;width:100%">查看实现</button>
            <div class="code-container" style="display:none">
              <pre><code class="language-cpp">class Solution {
 public:
     vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) {
         int n = nums.size();
         for (int i = 0; i &lt; n; ++i) {
             for (int j = i + 1; j &lt; n; ++j) {
                 if (nums[i] + nums[j] == target) {
                     return {i, j};
                 }
             }
         }
         return {};
     }
 };</code></pre>
            </div>
          </article>
          <article class="card">
            <h3>无重复字符的最长子串</h3>
            <p>滑动窗口与哈希集合，维护当前窗口的唯一性。</p>
            <button class="btn btn-outline btn-sm toggle-code" style="margin-top:16px;width:100%">查看实现</button>
            <div class="code-container" style="display:none">
              <pre><code class="language-cpp">class Solution {
 public:
     int lengthOfLongestSubstring(string s) {
         // 哈希集合，记录每个字符是否出现过
         unordered_set&lt;char&gt; occ;
         int n = s.size();
         // 右指针，初始值为 -1，相当于我们在字符串的左边界的左侧，还没有开始移动
         int rk = -1, ans = 0;
         // 枚举左指针的位置，初始值隐性地表示为 -1
         for (int i = 0; i &lt; n; ++i) {
             if (i != 0) {
                 // 左指针向右移动一格，移除一个字符
                 occ.erase(s[i - 1]);
             }
             while (rk + 1 &lt; n &amp;&amp; !occ.count(s[rk + 1])) {
                 // 不断地移动右指针
                 occ.insert(s[rk + 1]);
                 ++rk;
             }
             // 第 i 到 rk 个字符是一个极长的无重复字符子串
             ans = max(ans, rk - i + 1);
         }
         return ans;
     }
 };</code></pre>
            </div>
          </article>
          <article class="card">
            <h3>合并区间</h3>
            <p>排序后线性合并，处理重叠段。</p>
            <button class="btn btn-outline btn-sm toggle-code" style="margin-top:16px;width:100%">查看实现</button>
            <div class="code-container" style="display:none">
              <pre><code class="language-cpp">class Solution {
 public:
     vector&lt;vector&lt;int&gt;&gt; merge(vector&lt;vector&lt;int&gt;&gt;&amp; intervals) {
         if (intervals.size() == 0) {
             return {};
         }
         sort(intervals.begin(), intervals.end());
         vector&lt;vector&lt;int&gt;&gt; merged;
         for (int i = 0; i &lt; intervals.size(); ++i) {
             int L = intervals[i][0], R = intervals[i][1];
             if (!merged.size() || merged.back()[1] &lt; L) {
                 merged.push_back({L, R});
             }
             else {
                 merged.back()[1] = max(merged.back()[1], R);
             }
         }
         return merged;
     }
 };</code></pre>
            </div>
            </article>
          <article class="card">
            <h3>寻找两个正序数组的中位数</h3>
            <p>给定两个大小分别为 m 和 n 的正序（从小到大）数组 nums1 和 nums2。请你找出并返回这两个正序数组的中位数。算法的时间复杂度应该为 O(log (m+n))。</p>
            <button class="btn btn-outline btn-sm toggle-code" style="margin-top:16px;width:100%">查看实现</button>
            <div class="code-container" style="display:none">
              <pre><code class="language-cpp">class Solution {
 public:
     int getKthElement(const vector&lt;int&gt;&amp; nums1, const vector&lt;int&gt;&amp; nums2, int k) {
         /* 主要思路：要找到第 k (k&gt;1) 小的元素，那么就取 pivot1 = nums1[k/2-1] 和 pivot2 = nums2[k/2-1] 进行比较
          * 这里的 "/" 表示整除
          * nums1 中小于等于 pivot1 的元素有 nums1[0 .. k/2-2] 共计 k/2-1 个
          * nums2 中小于等于 pivot2 的元素有 nums2[0 .. k/2-2] 共计 k/2-1 个
          * 取 pivot = min(pivot1, pivot2)，两个数组中小于等于 pivot 的元素共计不会超过 (k/2-1) + (k/2-1) &lt;= k-2 个
          * 这样 pivot 本身最大也只能是第 k-1 小的元素
          * 如果 pivot = pivot1，那么 nums1[0 .. k/2-1] 都不可能是第 k 小的元素。把这些元素全部 "删除"，剩下的作为新的 nums1 数组
          * 如果 pivot = pivot2，那么 nums2[0 .. k/2-1] 都不可能是第 k 小的元素。把这些元素全部 "删除"，剩下的作为新的 nums2 数组
          * 由于我们 "删除" 了一些元素（这些元素都比第 k 小的元素要小），因此需要修改 k 的值，减去删除的数的个数
          */
 
         int m = nums1.size();
         int n = nums2.size();
         int index1 = 0, index2 = 0;
 
         while (true) {
             // 边界情况
             if (index1 == m) {
                 return nums2[index2 + k - 1];
             }
             if (index2 == n) {
                 return nums1[index1 + k - 1];
             }
             if (k == 1) {
                 return min(nums1[index1], nums2[index2]);
             }
 
             // 正常情况
             int newIndex1 = min(index1 + k / 2 - 1, m - 1);
             int newIndex2 = min(index2 + k / 2 - 1, n - 1);
             int pivot1 = nums1[newIndex1];
             int pivot2 = nums2[newIndex2];
             if (pivot1 &lt;= pivot2) {
                 k -= newIndex1 - index1 + 1;
                 index1 = newIndex1 + 1;
             }
             else {
                 k -= newIndex2 - index2 + 1;
                 index2 = newIndex2 + 1;
             }
         }
     }
 
     double findMedianSortedArrays(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) {
         int totalLength = nums1.size() + nums2.size();
         if (totalLength % 2 == 1) {
             return getKthElement(nums1, nums2, (totalLength + 1) / 2);
         }
         else {
             return (getKthElement(nums1, nums2, totalLength / 2) + getKthElement(nums1, nums2, totalLength / 2 + 1)) / 2.0;
         }
     }
 };</code></pre>
            </div>
          </article>
        </div>
      </div>

      <div id="algorithms" style="display:none">
        <div class="grid posts">
          <article class="card">
            <h3>二分查找</h3>
            <p>在有序数组中查找目标位置，时间复杂度 O(log n)。</p>
            <button class="btn btn-outline btn-sm toggle-code" style="margin-top:16px;width:100%">查看实现</button>
            <div class="code-container" style="display:none">
              <pre><code class="language-cpp">int binary_search(const vector&lt;int&gt;&amp; arr, int target){
    int l = 0, r = (int)arr.size() - 1;
    while(l &lt;= r){
        int m = (l + r) / 2;
        if(arr[m] == target) return m;
        else if(arr[m] &lt; target) l = m + 1;
        else r = m - 1;
    }
    return -1;
}</code></pre>
            </div>
          </article>
          <article class="card">
            <h3>最长上升子序列</h3>
            <p>贪心与二分优化。</p>
            <button class="btn btn-outline btn-sm toggle-code" style="margin-top:16px;width:100%">查看实现</button>
            <div class="code-container" style="display:none">
              <pre><code class="language-cpp">int LIS(const vector&lt;int&gt;&amp; nums){
    vector&lt;int&gt; d;
    for(int x : nums){
        auto it = lower_bound(d.begin(), d.end(), x);
        if(it == d.end()) d.push_back(x);
        else *it = x;
    }
    return (int)d.size();
}</code></pre>
            </div>
          </article>
          <article class="card">
            <h3>Dijkstra 最短路径</h3>
            <p>非负权图的单源最短路径。</p>
            <button class="btn btn-outline btn-sm toggle-code" style="margin-top:16px;width:100%">查看实现</button>
            <div class="code-container" style="display:none">
              <pre><code class="language-cpp">#include &lt;cstring&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;

using namespace std;

const int N = 510;

int n, m;
int g[N][N];
int dist[N];
bool st[N];

int dijkstra()
{
    memset(dist, 0x3f, sizeof dist);
    dist[1] = 0;

    for (int i = 0; i &lt; n - 1; i ++ )
    {
        int t = -1;
        for (int j = 1; j &lt;= n; j ++ )
            if (!st[j] &amp;&amp; (t == -1 || dist[t] &gt; dist[j]))
                t = j;

        for (int j = 1; j &lt;= n; j ++ )
            dist[j] = min(dist[j], dist[t] + g[t][j]);

        st[t] = true;
    }

    if (dist[n] == 0x3f3f3f3f) return -1;
    return dist[n];
}

int main()
{
    scanf("%d%d", &amp;n, &amp;m);

    memset(g, 0x3f, sizeof g);
    while (m -- )
    {
        int a, b, c;
        scanf("%d%d%d", &amp;a, &amp;b, &amp;c);

        g[a][b] = min(g[a][b], c);
    }

    printf("%d\n", dijkstra());

    return 0;
}</code></pre>
            </div>
          </article>
          <article class="card">
            <h3>二分查找模板</h3>
            <p>左右边界不同场景的模板。</p>
            <button class="btn btn-outline btn-sm toggle-code" style="margin-top:16px;width:100%">查看实现</button>
            <div class="code-container" style="display:none">
              <pre><code class="language-cpp">bool check(int x)
{
    if(满足题设条件)
        return true;
    return false;
}

int binary_search1(int l , int r)
{
    while(l &lt; r)
    {
        int mid = l + r + 1 &gt;&gt; 1; // l先动要加1 !! !! !!
        if(check(mid)
            //看具体题目来选择是l动还是r动 这是l先动的情况
            l = mid;
        r = mid - 1;
    }

    return l;
}

int binary_search1(int l , int r)
{
    while(l &lt; r)
    {
        int mid = l + r + 1 &gt;&gt; 1; // r先动就不用 + 1
        if(check(mid)
            //看具体题目来选择是l动还是r动
            r = mid;
        l = mid + 1;
    }

    return l;
}</code></pre>
            </div>
          </article>
          <article class="card">
            <h3>前缀和</h3>
            <p>快速统计数序和</p>
            <button class="btn btn-outline btn-sm toggle-code" style="margin-top:16px;width:100%">查看实现</button>
            <div class="code-container" style="display:none">
              <pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;

const int N = 100010;

int n, m;
int a[N], s[N];

int main()
{
    scanf("%d%d", &n, &m);
    for (int i = 1; i &lt;= n; i ++ ) scanf("%d", &a[i]);

    for (int i = 1; i &lt;= n; i ++ ) s[i] = s[i - 1] + a[i]; // 前缀和的初始化

    while (m -- )
    {
        int l, r;
        scanf("%d%d", &l, &r);
        printf("%d\n", s[r] - s[l - 1]); // 区间和的计算
    }

    return 0;
}</code></pre>
            </div>
          </article>
        </div>
      </div>
    </div></section>
  </main>

  <footer class="footer"><div class="container inner"><div><strong class="brand"><div class="logo">IT</div>技术博客</strong></div><div style="display:flex;align-items:center;gap:8px"><img alt="hits" src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2FYAN-YONGCHUN.github.io%2FPersonal-blog%2Falgorithms.html&count_bg=%233498DB&title_bg=%232C3E50&icon=github.svg&icon_color=%23ffffff&title=views&edge_flat=false"></div></div></footer>

  <script src="./assets/app.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/prismjs@1/prism.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-javascript.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-c.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-cpp.min.js"></script>
</body>
</html>
